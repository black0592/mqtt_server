#include "http_server/http_connection.hpp"
#include "common/str_tools.hpp"

namespace http
{
    int HttpConnection::handle_input(socket_t)
    {
	LOG_TRACE_METHOD(__func__);

	int read_len = ::read(this->m_sock_handle, m_recv_buffer + m_cur_buf_pos, HttpConnection::MAX_BUF_SIZE - m_cur_buf_pos);
	if (read_len < 0)
	{
	    int my_errno = errno;
	    if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)
	    {
		LOG_DEBUG("Read len < 0, errno %d, return 0 continue", my_errno);
		return 0;
	    }
	}

	LOG_DEBUG("HTTP Connection: handle_input read data len %d, socket [%d]", read_len, this->m_sock_handle);
	if (read_len <= 0)
	{
	    LOG_INFO("peer close the socket [%d],read_len %d, %s close now", this->m_sock_handle, read_len, strerror(errno));
	    return -1;
	}

	m_recv_times++;
	m_recv_bytes += read_len;

	m_cur_buf_pos += read_len;

	m_recv_buffer[m_cur_buf_pos] = '\0';
	m_last_msg_time  = time(0);
	return this->process(m_recv_buffer, m_cur_buf_pos);
    }

    int HttpConnection::process(uint8_t *buf, uint32_t UNUSED(len))
    {
	LOG_DEBUG("HTTP Content \n%s", (char *)buf);

	HTTPRequest req;
	HTTPResponse response;

	int res = this->parse_headers((char *)buf, &req, &response);
	LOG_DEBUG("parse_headers res %d, req.path [%s]", res, req.path.c_str());

	if (req.path.compare("/favicon.ico") == 0)
	{
	    LOG_DEBUG("Find get favicon request, just return now");
	    return -1; // just ignore
	}

	std::string error;

	if ( (res == -1) || (req.path.compare("/publish") != 0))
	{
	    LOG_DEBUG("Send not found 404 to client");
	    response.code = 404;
	    response.phrase = "Not Found";
	    response.type = "text/html";
	    response.append("<html>\n"\
		    "<head><title>404 Not Found</title></head>\n" \
		    "<body bgcolor=\"white\">\n" \
		    "<center><h1>404 Not Found</h1></center>\n" \
		    "<hr><center>http_server  / 1.0.0</center>\n" \
		    "</body>\n" \
		    "</html>\n");
	}
	else
	{
	    response.type = "text/html";
	    if (this->notify_mqtt_publish(req, error) == -1)
	    {
		response.code = 400;
	    }
	    else
	    {
		error = "Publish msg succeed";
		response.code = 200;
	    }

	    response.append("<html>\n"\
			"<head><title>Succeed</title></head\n" \
			"<body bgcolor=\"white\">\n" \
			"<center><h1>");
	    
	    response.append(error);

	    response.append("</h1></center>\n</body>\n<html>\n");
	}

	this->http_send(response.body.str().c_str(), strlen(response.body.str().c_str()));

	return 0; //wait for close socket
    }

    int HttpConnection::notify_mqtt_publish(HTTPRequest &req, std::string &error)
    {
	// make mqtt publish msg and notify to mqtt server
	std::string str_client_id;
	std::string str_topic_name;
	std::string str_qos;
	std::string str_retain_flag;
	std::string str_msg;

	uint8_t retain = 0;
	uint8_t qos = 1;

	error.clear();

	// must be
	if (req.query_param("client", str_client_id) == -1)
	{
	    // error description
	    error += "client param must be supplied\n";
	}

	// msut be
	if (req.query_param("topic", str_topic_name) == -1)
	{
	    // error descripiton
	    error += "topic param must be supplied\n";
	    return -1;
	}

	// must be
	if (req.query_param("msg",str_msg) == -1)
	{
	    // error description
	    error += "msg param msut be supplied";
	    return -1;
	}

	// optional
	if (req.query_param("qos", str_qos) != -1)
	{
	    qos = atoi(str_qos.c_str());
	    if (qos > 1)
	    {
		qos = 1;
	    }
	}

	// opational
	if (req.query_param("retain", str_retain_flag) == -1)
	{
	    retain = atoi(str_retain_flag.c_str());
	    if (retain > 1)
	    {
		retain = 1;
	    }
	}

	if (!error.empty())
	{
	    return -1;
	}
	
	return 0;
    }

    int HttpConnection::parse_headers(char* headers, HTTPRequest* req, HTTPResponse* UNUSED(res))
    {
	int i = 0;
	char * pch;
	char * context;
	for (pch = strtok_safe(headers, "\n", &context); pch; pch = strtok_safe(NULL, "\n", &context))
	{
	    std::string line(pch);
	    str_tools::trim(line);

	    if (line.empty()) // header \r\n\r\n body
	    {
		continue;
	    }

	    LOG_DEBUG("Line [%s], size %d", line.c_str(), (int)line.length());

	    if (i++ == 0)
	    {
		std::vector<std::string> R;
		str_tools::split(line, " ", 3, &R);

		if (R.size() != 3) {
		    /* throw error */
		    LOG_DEBUG("stop at R.size() != 3");
		    return -1;
		}

		req->method = R[0];
		req->path = R[1];

		size_t pos = req->path.find('?');

		/* We have GET params here */
		if (pos != std::string::npos)
		{
		    std::vector<std::string> Q1;
		    str_tools::split(req->path.substr(pos + 1), "&", -1, &Q1);

		    for (std::vector<std::string>::size_type q = 0; q < Q1.size(); q++)
		    {
			std::vector<std::string> Q2;
			str_tools::split(Q1[q], "=", -1, &Q2);

			if (Q2.size() == 2)
			{
			    req->query[Q2[0]] = Q2[1];
			}
		    }

		    req->path = req->path.substr(0, pos);
		}
		else
		{
		    if (req->method.compare("POST") == 0)
		    {
			str_tools::remove_space(req->path);
		    }
		}
	    }
	    else
	    {
		std::vector<std::string> R;
		str_tools::split(line, ": ", 2, &R);

		if (R.size() == 2) {
		    req->headers[R[0]] = R[1];

		    /* Yeah, cookies! */
		    /*
		       if (R[0] == "Cookie") {
		       std::vector<std::string> C1;
		       str_tools::split(R[1], "; ", -1, &C1);

		       for (std::vector<std::string>::size_type c = 0; c < C1.size(); c++)
		       {
		       std::vector<std::string> C2;

		       str_tools::split(C1[c], "=", 2, &C2);

		       req->cookies[C2[0]] = C2[1];
		       }
		       }
		       */
		}
		else
		{
		    /* for POST method */
		    if (req->method.compare("POST") == 0)
		    {
			LOG_DEBUG("Deal POST method");
			R.clear();

			str_tools::split(line, "&", 3, &R);
			for (std::vector<std::string>::size_type j = 0; j < R.size(); ++j)
			{
			    std::vector<std::string> data;
			    str_tools::split(R[j], "=", 2, &data);
			    req->query[data[0]] = data[1];
			}
		    }
		}
	    }
	}

	return 0;
    } // end of parse header

    int HttpConnection::http_send(const char* data, uint32_t length)
    {
	HTTPResponse res;
	char header_buffer[1024];
	std::string body;
	body.append(data, length);

	/* build http response */
	snprintf(header_buffer,
		sizeof(header_buffer),
		"HTTP/1.0 %d %s\r\n" \
		"Server: %s %s\r\n" \
		"Date: %s\r\n" \
		"Content-Type: %s\r\n" \
		"Content-Length: %d\r\n",
		res.code, res.phrase.c_str(),
		"HttpServer", "1.0",
		res.date.c_str(),
		res.type.c_str(),
		length
		);

	/* append extra crlf to indicate start of body */
	strcat_safe(header_buffer, "\r\n");

	std::string response_data = "";
	response_data.append(header_buffer, strlen(header_buffer));
	response_data.append(body);

	return this->write_n((uint8_t *)response_data.c_str(), response_data.size());
    }
}
